# 인코딩(Encoding)

## 컨텐츠 인코딩

HTTP 애플리케이션에서는 컨텐츠를 보낼 떄 아래와 같은 이유로 컨텐츠 인코딩을 사용하게 된다.

- 전송 비용을 줄이기 위한 압축 목적
- 허가받지 않은 접근으로부터 보호하기 위한 암호화 목적

### 인코딩 과정

1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 포함한 원본 응답 메시지 생성
2. 컨텐츠 인코딩 서버가 인코딩된 메시지 생성
    - Content-Type은 같지만 Content-Length 다른 메시지가 생성
    - Content-Encoding 헤더에 인코딩된 메시지를 추가
3. 수신 측 프로그램에서 인코딩된 메시지를 받아 Content-Encoding 헤더를 확인하여 디코딩

### 컨텐츠 인코딩 유형

HTTP는 기본적으로 표준 컨텐츠 인코딩 유형을 정의해주고 확장 인코딩으로 추가를 하는 것을 허용한다.  
인코딩은 각 컨텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화하며, Content-Encoding 헤더는 표준화된 토큰 값을 이용해 사용된 알고리즘을 명시한다.  
gzip / compress / deflate / identity 등이 있으며 gzip이 일반적으로 가장 효율적이고 많이 사용된다.

### Accept-Encoding 헤더

클라이언트는 Accept-Encoding 헤더를 통해 서버에서 클라이언트가 지원하지 않는 인코딩을 사용하지 않도록 요청할 수 있다.

## 전송 인코딩

컨텐츠 인코딩은 메시지의 엔티티 부분만 인코딩하지만 전송 인코딩은 메시지 전체를 인코딩하여 구조를 바꾼다.  
전송 인코딩은 보안을 위해 존재했으나 사용할 수는 있지만 SSL 같은 보안 프로토콜을 사용하는 더 좋은 대안이 있기 때문에 전송 인코딩 보안은 거의 사용되지 않는다.

### Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 아래 두 개 뿐이다.

- Transfer-Encoding: 안전한 전송을 위해 사용된 인코딩 방식
- TE: 어떤 전송 인코딩을 받아들일 수 있는지 서버에 알려주기 위한 값(= Accept-Transfer-Encoding 라는 이름이 더 적절한 역할을 가짐)

## 청크 인코딩(전송 인코딩)

메시지를 일정 크기의 청크 여럿으로 쪼갠 후 각 청크를 순차적으로 보내는 방식이다.  
청크 인코딩은 전송 인코딩의 한 형태이기 때문에 본문이 아닌 메시지의 속성임을 명심해야 한다.

### 지속 커넥션

클라이언트 - 서버 간 커넥션이 지속적이지 않다면 클라이언트가 본문의 크기가 알 필요가 없다.(모두 전송 후 커넥션을 끊기 때문)  
하지만 지속 커넥션에서는 본문의 크기를 알아야 해당 메시지의 끝을 알 수 있기 때문에 본문의 크기를 알려주는 헤더가 필요하다.  
하지만 컨텐츠가 서버에서 동적으로 생성되는 경우에는 본문의 크기를 알 수 없기 때문에 청크 인코딩을 사용한다.

### 청크 인코딩의 전송 방식

1. 전송할 본문을 버퍼에 담은 뒤 한 덩어리를 큭기와 함께 전송
2. 본문을 모두 보낼 때까지 1번 과정을 반복
3. 마지막에 크기가 0인 청크로 본문이 끝났음을 알림

### 청크 인코딩된 메시지의 트레일러

아래의 조건 중 하나 이상을 만족하는 경우에는 청크 인코딩된 메시지에 트레일러(본문 다음에 오는 추가적인 헤더 정보를 추가할 수 있다.

- 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 알려준 경우
- 트레일러가 응답을 만든 서버에 의해 추가됐으며, 클라이언트가 이해하고 사용할 필요가 없는 선택적인 정보일 경우(클라이언트가 무시하고 버려도 되는 경우)

###### 참고자료

- [HTTP 완벽 가이드](https://www.nl.go.kr/seoji/contents/S80100000000.do?schM=intgr_detail_view_isbn&page=1&pageUnit=10&schType=simple&schStr=HTTP+완벽+가이드&isbn=9788966261208&cipId=200309770%2C4096969)