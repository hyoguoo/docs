# 커넥션(Connection)

커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 안 좋아질 수 있다.  
만약 세 개의 데이터를 전송해야 하는데, 각각의 데이터를 전송하기 위해 커넥션을 맺고 끊는다면, 각 트랜잭션마다 TCP 핸드쉐이크가 일어나고, TCP 커넥션을 맺고 끊는 과정이 필요하게 되어 매우 비효율적이다.

|              연결 방법               |                   연결 방식                    |
|:--------------------------------:|:------------------------------------------:|
| 개별 연결(Non-Persistent Connection) |            연결 후 요청 후 응답 후 연결 종료            |
|    병렬 연결(Parallel Connection)    |        여러 개의 TCP 커넥션을 통한 동시 HTTP 요청        |
|   지속 연결(Persistent Connection)   | 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위해 TCP 커넥션 재활용 |
|  파이프라인 연결(Pipelined Connection)  |          공유 aTCP 커넥션을 통한 HTTP 요청           |
|  다중 연결(Multiplexing Connection)  |           요청과 응답들에 대한 중재(실험적 기술)           |

초기 HTTP 에서는 실제로 통신 한 번 할때마다 TCP에 의해 연결이 되고 종료됐으나 이를 해결하기 위해 여러 연결 방법이 나왔다.

## 병렬 연결(Parallel Connection)

여러 개의 TCP 커넥션을 통해 동시에 HTTP 트랜잭션을 병렬로 처리할 수 있도록 하는 방식으로, 대역폭에 여유가 있는 한 더 빠르게 데이터를 주고 받을 수 있다.  
하지만 다수의 커넥션이 메모리를 많이 소모하고 성능 저하 문제를 유발 시킬 수 있다.

## 지속 연결(Persistent Connection)

웹 사이트는 보통 같은 사이트에 여러 개의 커넥션을 맺게 되는데, 처리가 완료된 커넥션을 계속 유지하여 다음 요청을 처리할 때 재사용하는 방식이다.  
이를 통해 TCP 핸드쉐이크를 줄일 수 있고, 커넥션을 맺고 끊는 데서 발생하는 지연을 제거할 수 있다.

### 병렬 vs 지속

병렬 커넥션은 여러 객체가 있는 페이지를 빠르게 전송하지만 몇 가지 단점이 존재한다.

- 각 트랜잭션마다 새로운 커넥션 생성 및 종료
- 각 커넥션마다 TCP 느린 시작(slow start) 문제 발생
- 제한적인 실제 연결 가능한 커넥션 수

이에 반해 지속 커넥션은 위의 단점을 보완할 수 있어, 현대 웹 애플리케이션에서는 적은 수의 병렬 커넥션을 지속하는 것을 사용한다.

### Keep-Alive

HTTP/1.0에서 `Connection: Keep-Alive` 헤더를 통해 지속 커넥션을 사용할 수 있도록 지원하였다.  
HTTP/1.1에서 명세에서 빠지게 되었지만, 여전히 많은 웹 서버가 `keep-alive`를 지원하고 있기 떄문에 HTTP 애플리케이션은 해당 헤더를 처리할 수 있게 개발을 할 필요가 있다.

- `Connection: Keep-Alive` 헤더를 포함시켜 응답을 보낸 경우: 지속 커넥션을 계속 유지하는 것으로 판단
- 헤더를 포함시키지 않은 경우: 클라이언트 측에서 지속 커넥션을 종료하는 것으로 판단하여 커넥션을 종료

#### Keep-Alive 옵션

Keep-Alive 헤더는 커넥션을 유지하기 바라는 요청일 뿐이며 클라이언트나 서버가 반드시 지속 커넥션을 유지할 필요는 없다.  
언제든지 커넥션이 종료될 수 있으며 해당 동작에 대해 `Keep-Alive: timeout=5, max=1000` 처럼 옵션을 설정할 수 있다.  
하지만 해당 옵션들도 클라이언트나 서버가 반드시 지킬 필요는 없기 때문에 보장받을 수 없다.

- timeout: 커넥션을 유지할 수 있는 시간
- max: 한 커넥션이 처리할 수 최대 HTTP 트랜잭션 수
- 그 외 임의 속성

#### Keep-Alive와 Proxy

프락시와 게이트웨이는 Connection 헤더의 규칙을 철저하게 지켜야 한다. 그렇지 않고 프락시에서 keep-alive를 사용하게 되면 아래와 같은 시나리오와 함께 문제가 발생할 수 있다.

1. 클라이언트가 서버에게 keep-alive 커넥션을 요청
2. 프락시에서 요청 받은 HTTP Connection 헤더를 서버에 그대로 전달
3. 서버는 keep-alive 커넥션을 유지하기 위해 헤더를 포함하여 응답을 보냄
4. 해당 응답을 프락시가 수신하여 서버는 프락시와 keep-alive 커넥션 상태로 통신하는 것으로 판단
5. 프락시에서 받은 응답을 클라이언트에게 전달
6. 응답을 받은 클라이언트도 서버와 keep-alive 커넥션 상태로 통신하는 것으로 판단
7. 서버는 프락시와 keep-alive 커넥션 상태로 통신하고 있으나 프락시는 서버의 커넥션 종료 요청을 대기
8. 이 상태에서 클라이언트가 다음 요청 전송
9. 프락시는 같은 커넥션 상에서 다른 요청이 오는 경우를 예상하지 못하기 때문에 해당 요청이 무시되고 서버에 전달되지 않음
10. 커넥션이 끊길 때까지 네트워크 문제 지속

이와 같은 문제를 해결하기 위해서는, `Proxy-Connection` 헤더를 사용하도록 권장하고 있다.  
프락시가 해당 헤더를 무조건 전달하더라도, 서버에서는 해당 헤더를 무지하기 때문에 문제가 발생하지 않게 되며,  
만약 프락시가 해당 헤더를 `Connection` 헤더로 전달하게 되면 클라이언트가 원하던 keep-alive 커넥션을 유지할 수 있게 된다.  
하지만 여러 개의 프락시가 중첩되어 있는 경우에는 해당 헤더를 사용하지 못 한다.(한 프락시에서라도 `Proxy-Connection` 헤더를 인지 못하면 문제가 발생하기 때문)  
결국 브라우저에서는 중첩된 프락시들의 상태를 알 수 없기 때문에 `Proxy-Connection` 헤더를 사용하지 않는 것이 좋다.

### HTTP/1.1

`Keep-Alive`가 명세에서는 빠지게 되고 기본적으로 지속 커넥션이 활성화 된 상태로, 별도 설정이 없는 한 모든 커넥션을 지속 커넥션으로 유지한다.  
트랜잭션이 끝나고 커넥션을 종료하고 싶다면 `Connection: close` 헤더를 통해 커넥션을 종료하도록 명시할 수 있다.

## 파이프라인 연결(Pipelined Connection)

지속 커넥션을 통해 요청을 파이프라이닝 하는 방법으로, 여러 개의 요청을 응답이 도착하기 전에 보내는 방식이다.  
대기 시간이 긴 네트워크 상황에서 네트워크 왕복으로 인한 시간을 줄여 성능을 높여주지만 아래와 같은 제약 사항이 있다.

- HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인 전엔 파이프라인 연결을 사용할 수 없다.
- 요청 순서와 응답이 같아야 하며, 메시지 자체에 순번이 없기 때문에 응답의 순서를 구분할 수 없다.
- HTTP 클라이언트는 커넥션이 언제 끊어지더라도, 완료되지 않은 요청이 파이프라인에 있으면 다시 보낼 수 있어야 한다.
- POST 요청과 같은 비멱등 요청을 보내면 문제가 발생할 수 있기 때문에 멱등 요청만 파이프라인에 보낼 수 있다.

###### 참고자료

- [HTTP 완벽 가이드](https://www.nl.go.kr/seoji/contents/S80100000000.do?schM=intgr_detail_view_isbn&page=1&pageUnit=10&schType=simple&schStr=HTTP+완벽+가이드&isbn=9788966261208&cipId=200309770%2C4096969)