---
layout: editorial
---

# 프록시

> 실제 객체를 감싸고 호출된 메서드에 횡단 관심사를 적용하여 제어하는 중간 계층의 객체

일반적으로 클라이언트가 서버를 직접 호출하고, 처리 결과를 직접 받지만, 중간에 프록시(=대리자)를 두어 접근 제어나 부가 기능을 추가할 수 있다.  
프록시를 GOF 디자인 패턴 관점으로 봤을 때 프록시 패턴과 데코레이터 패턴이 있으며 그 역할은 다음과 같다.  
주의할 점은 본문에서 다루는 프록시와 GOF 디자인 패턴에서의 프록시는 전혀 다른 개념이며 이름만 같을 뿐이다.

- 접근 제어(=프록시 패턴)
    - 권한에 따른 접근 차단
    - 캐싱
    - 지연 로딩
- 부가 기능 추가(=데코레이터 패턴)
    - 원래의 서버가 제공하지 않는 기능 추가

여기서 하나의 프록시뿐만 아니라 여러 개의 프록시를 연결하여 체인 형태로 구성할 수 있다.

## JDK 동적 프록시 / CGLIB

프록시 객체를 생성하는 방법에 JDK 동적 프록시와 CGLIB가 있다.

- JDK 동적 프록시
    - 자바 언어에서 기본으로 제공하는 동적 프록시 기술로 인터페이스 기반 프록시 생성 지원
    - 인터페이스가 없으면 프록시를 생성할 수 없음
    - InvocationHandler에 기능을 구현하여 프록시를 생성하는 방식
- CGLIB
    - 스프링 프레임워크 라이브러리(이전엔 외부 라이브러리)로 클래스 기반 프록시 생성 지원
    - 클래스를 상속받아 프록시를 생성하기 때문에 인터페이스가 없어도 프록시를 생성할 수 있음
    - 스프링 부트에서 프록시를 생성할 때 Default로 CGLIB를 사용
    - 클래스나 메서드에 `final` 키워드가 있으면 상속이 불가능하거나 오버라이딩이 불가능하기 때문에 프록시를 생성할 수 없는 제약이 존재
    - MethodInterceptor에 기능을 구현하여 프록시를 생성하는 방식

구현하려는 프록시의 원본 객체에 인터페이스 여부에 따라서 사용하는 방법이 달라지며, 생성하는 방법도 다르기 때문에 스프링에서는 추상화하고 통일해 사용할 수 있도록 Proxy Factory를 제공한다.

## Proxy Factory

![ProxyFactory Flow](image/proxyfactory_flow.png)

프록시 생성(Proxy Factory)과 생성된 프록시에 요청(Advice Call)을 하게 되면 위와 같은 흐름으로 동작한다.

- Proxy Factory: 인터페이스가 있으면 JDK 동적 프록시를, 없으면 CGLIB를 사용하여 프록시 생성(설정을 주어 강제로 CGLIB를 사용할 수도 있음)
- Advice: 부가 기능을 담은 객체
- Target: 부가 기능을 적용할 대상 객체

### 포인트컷

또한, 스프링에서는 포인트컷으로 어떤 메서드에 부가 기능(Advice)을 적용할지 필터링해주는 기능을 제공하며 용어를 정리하면 다음과 같다.

- 포인트컷(Pointcut): 어떤 메서드를 어드바이스(부가 기능)를 적용할 지 선정하는 기능, 클래스와 메서드 이름으로 필터링 -> 필터 역할
- 어드바이스(Advice): 부가 기능을 제공하는 기능, 메서드 형태로 구현 -> 기능 로직 담당
- 어드바이저(Advisor): 포인트컷 + 어드바이스

## 빈 후처리기

ProxyFactory만으론 객체들을 하나하나 수동 등록해주어야 하기 때문에 설정 코드 자체도 길어지며, 컴포넌트 스캔을 하는 경우 프록시 객체 생성이 불가능하다.  
하지만 빈 후처리기를 이용하면 컴포넌트 스캔을 포함한 등록되는 빈들에 대해 프록시 객체를 적용하여 등록할 수 있다.  
또한 적용 될 빈을 필터링할 수 있기 때문에 특정 빈에만 프록시를 적용할 수도 있다.

## @Aspect

Proxy Factory와 빈 후처리기는 스프링이 제공하는 기능이지만, @Aspect는 스프링이 제공하는 기능은 아니다.  
@Aspect는 스프링 AOP를 사용하기 위한 어노테이션으로, 위의 Proxy Factory와 빈 후처리기를 사용하는 것보다 훨씬 간단하게 사용할 수 있다.

```java

@Aspect
public class ExampleAspect {

    @Around(value = "execution(* hello.proxy.app..*(..))") // Pointcut
    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {
        // Advice 로직
    }
}
```

어노테이션 기반으로 Pointcut과 Advice를 정의할 수 있으며, @Aspect를 보고 어드바이저로 변환하여 저장하는 과정은 다음과 같다.

1. 실행: 스프링 애플리케이션 로딩 시점에 자동 프록시 생성기를 호출
2. 모든 @Aspect 빈 조회: 자동 프록시 생성기는 스프링 컨테이너에서 @Aspect 애노테이션이 붙은 스프링 빈을 모두 조회
3. 어드바이저 생성: @Aspect 어드바이저 빌더를 통해 @Aspect 애노테이션 정보를 기반으로 어드바이저를 생성
4. @Aspect 기반 어드바이저 저장: 생성한 어드바이저를 @Aspect 어드바이저 빌더 내부에 저장

스프링은 최종적으로 다른 것을 통해 등록 된 Advisor와 @Aspect를 등록 된 Advisor를 모두 조회하여 프록시를 적용하게 된다.

## 프록시 내부 호출

대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하게 되어 프록시 기능이 적용되지 않는다.

```java
class Example {

    public void external() {
        // do something
        internal(); // 프록시를 거치지 않고 대상 객체 내부에서 메서드 호출하기 프록시 기능이 적용되지 않음
    }

    public void internal() {
        // do something
    }
}
```

위의 문제를 해결하기 위해서 프록시를 사용하는 것이 아닌 실제 코드에 AOP를 직접 적용하는 방법도 있으나, 복잡하기 때문에 그대로 프록시를 쓰면서 문제를 회피하는 방법을 사용한다.

- 자기 자신 주입
- 지연 조회
- 구조 변경(스프링에서 권장하는 방법)

## 스프링과 CGLIB

스프링에서는 프록시 객체를 생성할 때 기본적으로 CGLIB를 사용함으로써 얻을 수 있는 장점으로는 다음과 같다.

- 인터페이스가 없는 클래스도 프록시로 만들 수 있음
- 의존관계 주입 시 문제가 발생하지 않음(JDK 동적 프록시는 발생)

하지만 CGLIB는 클래스를 상속받아 프록시 객체를 생성하기 때문에 다음과 같은 제약사항이 존재했다.

1. 대상 클래스에 기본 생성자가 반드시 존재해야 함
2. 생성자 호출이 두 번 발생(실제 객체를 생성할 때 + 프록시 객체를 생성할 때)
3. final 클래스, final 메서드가 있는 경우 프록시를 생성할 수 없음

여기서 1번과 2번 문제는 `objenesis`라는 라이브러리를 사용하여 해결하였고, 3번 문제는 아직 해결하지 못했으나 final 키워드를 잘 사용하지 않기 때문에 큰 문제가 되지 않는다.

## ETC

- 프록시 객체는 스프링 컨테이너가 관리하고 자바 힙 메모리에도 올라간다. 반면에 실제 객체는 자바 힙 메모리에는 올라가지만 스프링 컨테이너가 관리하지는 않는다.

###### 참고자료

- [스프링 핵심 원리 - 고급편](https://www.inflearn.com/course/스프링-핵심-원리-고급편)