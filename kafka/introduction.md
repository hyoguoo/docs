---
layout: editorial
---

# Introduction

현대의 분산 시스템 환경에서 서비스 간의 데이터 연동 복잡성은 기하급수적으로 증가하는데, 카프카는 시스템 간의 결합도를 낮추고 데이터 흐름을 체계적으로 관리해준다.

## 카프카 핵심 개념

카프카는 분산 커밋 로그(Distributed Commit Log)이자 이벤트 스트리밍 플랫폼으로, 이벤트, 스트림, 그리고 분산 커밋 로그를 핵심 개념으로 한다.

1. 이벤트(Event): 과거에 발생한 사건에 대한 불변(Immutable)의 사실 기록으로, 비즈니스 혹은 시스템의 상태 변화
2. 스트림(Stream): 시간에 따라 순서대로 발생하는 이벤트의 연속적인 흐름
3. 분산 커밋 로그(Distributed Commit Log): 데이터베이스의 커밋 로그처럼, 데이터는 추가만 가능한(Append-only) 형태로 순서대로 기록(불변성

## 핵심 아키텍처 원칙

1. 높은 처리량(High Throughput)
    - OS 레벨의 최적화를 통해 높은 처리량을 달성
    - 데이터를 기록할 때, 임의의 위치에 쓰는 랜덤 I/O가 아닌 디스크의 끝에 순차적으로 쓰는 시퀀셜 I/O(Sequential I/O) 방식 사용
    - 컨슈머에게 데이터를 전달 시 커널에서 네트워크 카드로 직접 데이터를 전송하는 제로 카피(Zero-Copy) 기술을 사용으로, 전송 성능을 극대화
2. 확장성과 병렬처리(Scalability & Parallelism)
    - 하나의 토픽은 여러 개의 파티션으로 나뉠 수 있으며, 이 파티션이 병렬처리의 기본 단위
    - 프로듀서는 여러 파티션에 동시에 데이터를 쓸 수 있고, 컨슈머 그룹 내의 컨슈머들은 각기 다른 파티션을 할당받아 동시에 데이터를 읽어갈 수 있dma
    - 처리량을 높이고 싶을 때 파티션 수를 늘리고 그에 맞춰 컨슈머 수를 조절하는 방식으로 수평적 확장 가능
3. 내구성과 고가용성(Durability & Fault Tolerance)
    - 리플리케이션(Replication)을 통해 내구성 보장
    - 각 파티션은 리더(Leader)와 여러 팔로워(Follower) 리플리카로 구성되며, 팔로워는 리더의 데이터를 비동기적으로 복제
    - 프로듀서가 `acks=all` 옵션으로 메시지를 전송하면, 리더뿐만 아니라 팔로워까지 데이터 저장을 완료했음을 확인한 후에야 전송 성공 간주

## 기존 메시징 시스템과의 패러다임 차이

카프카는 기존 메시징 시스템(예: RabbitMQ)과 근본적인 패러다임의 차이를 가진다.

- 기존 메시징 시스템은 브로커가 메시지를 컨슈머에게 능동적으로 전달(Push)하고, 소비된 메시지는 큐에서 제거하는 구조
- 카프카는 브로커가 데이터를 저장만 하고, 컨슈머가 필요할 때 데이터를 가져가는(Pull) 구조
    - 브로커는 단순히 데이터를 커밋 로그에 저장하는 역할만 수행하며, 메시지를 삭제하지 않음(정책에 따라 다름)
    - 컨슈머가 자신의 필요에 따라 데이터를 가져가고, 어디까지 읽었는지를 나타내는 오프셋(Offset)을 스스로 관리하고 커밋
