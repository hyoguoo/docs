# 역할/책임/협력

## 협력

요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의

## 책임

### 책임의 분류

- `Doing`
    - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어하고 조절하는 것
- `Knowing`
    - 자신의 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

책임은 객체 지향 설계 품질을 결정하는 가장 중요한 요소이며, 외부에 제공할 수 있는 정보(`Knowing`)와 제공해 줄 수 있는 서비스(`Doing`)의 목록이다.  
객체를 설계할 때에 책임을 `public interface` 구성할 수 있다.

### 책임과 메시지

협력 안에서 객체는 다른 객체로부터 요청이 전송됐을 경우에만 자신에게 주어진 책임을 수행하는데,  
객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 메시지 전송(`message-send`)이라고 한다.  
-> 따라서 두 객체간의 협력은 `메시지`를 통해 이뤄진다고 볼 수 있다.
> 객체지향 설계는 협력에참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작하는 것이며,  
> 어떤 클래스가 필요하고 어떤 메서드를 포함해야 하는지는 책임과 메시지에 대한 청사진이 그려진 후에 시작하는 것이 좋다.

## 역할

책임의 집합은 역할이라는 의미를 갖게된다. 동일한 책임의 집합이 있다면 동일한 역할을 수행할 수 있다는 것을 의미한다.  
이처럼 유사한 협력을 협력을 역할이란 개념으로 추상화하여 재사용할 수 있다.  
더 나아가 객체지향 설계의 단순성(`simplicity`), 유연성(`flexibility`), 재사용성(`reusability`)을 뒷받침하는 핵심 개념이 된다.

### 협력의 추상

역할의 가장 큰 가치는 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 하여 협력을 `추상화`할 수 있다는 것이다.  
협력의 추상화는 다뤄야하는 협력의 개체를 줄이면서 구체적 객체를 추상화된 역할로 대체함으로써 애플리케이션의 설계를 이해하기 쉬워진다.

### 대체 가능성

역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자이므로, 다른 객체에 의해 대체 가능함을 의미한다.  
그렇다고 아무 객체가 역할을 대체하는 것이 아닌 해당 역할(책임의 집합)을 모두 수행할 수 있어야 한다.(해당 역할보다 더 많은 책임을 가질 수 있다.)
> 역할의 대체 가능성 = 행위의 호환성 = 동일한 책임의 수행₩

## 객체의 모양을 결정하는 협력

객체가 시스템에 필요한 데이터를 저장하기 위해 존재한다고 오해하기 쉽지만, 객체는 데이터를 포함하고 행위를 수행하는 데 필요할 뿐, 행위를 수행하며 협력에 참여하기 위해 존재한다.  
또한 클래스-클래스 간의 관계를 표현하는 시스템의 정적인 측면에만 중점을 두는 것이 아니라, 협력에 참여하는 동적인 객체에 중점을 두어야 한다.(클레스는 객체 구현 메커니즘 중 하나)  
각 객체를 독립적으로 바라보면 안 되고, `협력이라는 문맥을 고려하여 설계`해야 클래스 중심이 아닌 객체지향적인 설계할 수 있다.

### 협력을 따라 흐르는 객체의 책임

올바른 객체 설계는 견고하고 깔끔한 협력 설계에서 나온다.  
협력에 참여하는 객체들이 어떤 책임을 수행할지 결정하면, 책임은 곧 객체가 외부에 제공하게 될 행동이 된다.  
그 후에 객체가 수행하게 될 적절한 책임을 수행하는 데 필요한 데이터를 고민해야한다. 그리고 데이와 행동이 결정 된 후에 클래스 구현 방법을 결정해야한다.

## 객체지향 설계 기법

### 책임 주도 설계(`Responsibility-Driven Design`)

객체지향 설계란 애플리케이션의 기능을 구현하기 위한 협력 관계를 고안하고, 협력에 필요한 역할과 책임을 식별한 후 적절한 객체에게 책임을 할당하는 것이다.  
설계 시점에서 정해지는 것이 아닌 전체 개발 단계에 걸쳐 객체의 역할과 책임/협력을 주의하여 만드는 기법과 체계를 따르는 것이 중요하다.  
책임-주도 설걔는 말 그대로 객체의 책임 중심으로 시스템을 구축하는 것인데, 시스템의 책임을 객체의 책임으로 반환하고,  
각 객체가 책임을 수행하는 중에 필요한 정보나 서비스를 제공할 협력자를 찾아 해당 협력가에게 책임을 할당하는 순차적인 방식으로 협력 공동체를 설계한다.  
이처럼 개별적인 객체를 설계하는 것이 아닌, 객체들이 수행하는 책임과 상호작용을 중심으로 시스템을 설계하는 것이다.

- 시스템이 사용자에게 제공해야 하는 기능(시스템 책임) 파악
- 시스템 책임을 더 작은 책임으로 분할
- 분할된 책임을 수행할 수 있는 적절한 객체(역할)을 찾아 책임을 할당
- 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 객체(역할) 탐색
- 해당 객체(역할)에 책임을 할당함으로써 두 객체 협력 관계 시작

### 디자인 패턴

책임-주도 설계는 객체의 역햘/책임/협력을 고한하기 위한 방법 및 `절차`를 제시한 반면, 디자인 패턴은 책임-주도 설계의 `결과`를 표현한다.  
아무것도 없는 상태보다는 이전의 훌륭한 결과물을 모방하고 약간의 수정을 거쳐 결과물을 만드는 것이 더 훌륭한 결과물을 만들 수 있다.  
이처럼 디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의되는데 특정한 상황에 적용 가능한 디자인 패턴을 알고 있다면  
설계의 절차를 순차적으로 따르지 않고 빠르고 손쉽게 결과물을 만들어 낼 수 있다.

### 테스트-주도 개발

기본 흐름은 실패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작상한 후 리팩터링을 통해 중복 된 부분을 제거하는 것이다.  
테스트-주도 개발이 응집도가 높고 결합도가 낮은 클래스로 구성된 시스템을 개발할 수 있게 하는 최상의 프랙티스지만 경험이 적은 경우 접근 방법 자체에 대해 어려움을 느끼게 된다.  
테스트-주도 개발은 테스트를 작성하는 것이 아닌, 책임을 수행할 객체가 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지 기대를 코드 형태로 작성하는 것이다.  
결국 `테스트-주도 개발은 책임-주도 설계의 기본 개념을 따르게 되며` 객체지향에 대해 깊이 있는 지식을 요구하게 된다.

###### 출처

- 객체지향의 사실과 오해