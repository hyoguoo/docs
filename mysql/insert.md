---
layout: editorial
---

# INSERT

일반적인 애플리케이션 서비스에서는 INSERT 할 때 대부분 한 건 혹은 소량의 레코드만 추가하는 형태인데, 이 경우엔 성능에 대해 고려할 부분이 없다.

## 삽입 옵션

### INSERT IGNORE

저장하는 레코드의 프라이머리 키나 유니크 인덱스 컬럼의 값이 이미 테이블에 존재하는 레코드와 중복되는 경우, 저장하는 레코드 컬럼이 테이블의 컬럼과 호화니되지 않은 경우 모두 무시하고 저장한다.  
INSERT 하고자 하는 데이터가 정교하지 않아도 되는 경우에 사용하면, 중복 체크를 하지 않으며, 데이터 타입이 일치하지 않는 경우엔 자동으로 컬럼의 기본 값을 저장한다.

### INSERT ... ON DUPLICATE KEY UPDATE

INSERT + UPDATE 기능을 하는 옵션으로, 저장하려는 레코드의 프라이머리 키나 유니크 인덱스 컬럼의 값이 이미 테이블에 존재하는 레코드와 중복되는 경우 UPDATE를 수행한다.

## LOAD DATA

LOAD DATA 명령을 사용하면 MySQL 엔진과 스토리지 엔진 호출 횟수를 최소화하고 스토리지 엔진이 직접 데이터를 적재하기 때문에 일반적인 INSERT 명령보다 빠르다.  
하지만 LOAD DATA 명령은 아래 두 가지 단점이 존재한다.

- 단일 스레드로 수행
- 단일 트랜잭션으로 실행

적재하는 데이터가 매우 많은 양이 아니라면 위 두 가지는 문제가 되지 않지만, 데이터가 많아져 실행 시간이 길어지면 다른 트랜잭션 쿼리들의 성능을 영향을 줄 수 있으니 주의해야 한다.

## 성능을 위한 테이블 구조

SELECT와는 다르게 INSERT 쿼리 문장 자체에 튜닝할 수 있는 부분이 별로 없는 편이며, 테이블의 구조가 더 성능에 영향을 미친다.  
INSERT 성능에 영향을 미치는 요소로는 크게 PK가 있다.

한 번의 INSERT 문장으로 여러 건의 레코드를 저장하는 경우, 저장하는 레코드의 프라이머리 키 값이 정렬되어 있으면 성능이 좋아진다.  
정렬되지 않은 경우 레코드를 INSERT할 때마다 InnoDB 스토리지 엔진이 PK를 검색해서 저장할 위치를 찾아야 하기 때문이다.  
때문에 Auto-Increment 프라이머리 키를 사용하는 경우, 저장하는 레코드의 프라이머리 키가 항상 정렬되어 있으므로 성능이 좋아진다.

###### 참고자료

- [Real MySQL 8.0 (2권)](https://kobic.net/book/bookInfo/view.do?isbn=9791158392727)
