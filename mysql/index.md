---
layout: editorial
---

# Index(인덱스)

인덱스는 데이터베이스 테이블의 검색 성능을 향상시키기 위해 사용하는 자료구조이다.

- 장점:
    - 검색 속도 향상: 테이블 전체를 스캔하지 않고 인덱스를 통해 빠르게 조회 가능
    - 정렬 속도 향상: 이미 정렬된 인덱스를 읽어오므로 별도의 정렬 과정 생략 가능
- 단점:
    - 추가 저장 공간 필요: 인덱스는 원본 테이블과 별도의 저장 공간 필요
    - 쓰기 성능 저하: 데이터 변경 작업이 발생할 때마다, 테이블의 데이터뿐만 아니라 인덱스 정보도 함께 수정 필요

실제로 인덱스를 적용하면 큰 성능 향상을 가져올 수 있다.

```sql
SELECT {{SAME QUERY ...}}
-- [2023-04-14 02:52:38] 8 rows retrieved starting from 1 in 3 s 892 ms (execution: 3 s 876 ms, fetching: 16 ms)
-- CREATE INDEX ... completed in 29 s 426 ms
SELECT {{SAME QUERY ...}}
-- [2023-04-14 02:53:19] 8 rows retrieved starting from 1 in 73 ms (execution: 55 ms, fetching: 18 ms)
```

## 인덱스의 종류와 특징

인덱스는 역할, 데이터 저장 방식, 구성 등 다양한 기준에 따라 분류할 수 있다.

### 역할에 따른 분류

- 프라이머리 키 (Primary Key): 테이블에서 각 레코드를 고유하게 식별하는 역할을 하는 인덱스
    - `NULL` 값 허용 X
    - 테이블당 하나만 존재
    - 클러스터형 인덱스로 관리(InnoDB 기준)
- 보조 인덱스 (Secondary Index): 프라이머리 키를 제외한 모든 인덱스

### 데이터 저장 방식(InnoDB 기준)

- 클러스터형 인덱스(Clustered Index)
    - 프라이머리 키에 의해 생성
    - 키 값의 순서에 따라 테이블의 데이터가 물리적으로 정렬되어 저장
    - 인덱스의 리프 노드가 곧 데이터 레코드 자체이므로, 프라이머리 키로 검색 시 데이터 조회 속도가 매우 빠름
    - 테이블당 하나만 존재
- 비클러스터형 인덱스(Non-Clustered Index)
    - 보조 인덱스에 해당
    - 데이터가 아닌 프라이머리 키 값을 리프 노드에 저장
    - 데이터를 조회할 경우, 인덱스에서 프라이머리 키 값을 찾은 후, 다시 클러스터형 인덱스를 통해 최종 데이터 레코드를 찾는 과정이 필요

### 기타 분류

- 유니크 인덱스(Unique Index): 프라이머리 키와 유사하게 중복된 값을 허용하지 않는 인덱스
  - 프라이머리 키와 달리 `NULL` 값 허용
  - 여러 개 생성 가능
- 복합 인덱스(Composite Index): 두 개 이상의 컬럼을 조합하여 생성한 인덱스

###### 참고자료

- [Real MySQL 8.0 (1권)](https://kobic.net/book/bookInfo/view.do?isbn=9791158392703)
