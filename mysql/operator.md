---
layout: editorial
---

# Operator(연산자)

MySQL의 연산자는 대부분 표준을 따르지만, 일부는 MySQL에만 존재하는 비표준 형태를 가지고 있어 다른 DBMS와의 호환성 및 코드의 일관성을 위해 가급적 SQL 표준 연산자를 사용하는 것이 권장된다.

## 비교 연산자

### 동등 비교

- `=`: 두 값이 같으면 `TRUE`(1), 다르면 `FALSE`(0)를 반환
    - 피연산자 중 하나라도 `NULL`이 포함되면 결과는 항상 `NULL`
- `<=>` (NULL-safe equal to): MySQL 고유의 연산자
    - `=`와 동일하게 동작하지만 `NULL`을 일반적인 값으로 취급하여 비교
    - `NULL <=> NULL` -> `TRUE`(1) / `값 <=> NULL` -> `FALSE`(0)

| 비교 | `1 = 1` | `NULL = NULL` | `1 = NULL` | `1 <=> 1` | `NULL <=> NULL` | `1 <=> NULL` |
|:---|:-------:|:-------------:|:----------:|:---------:|:---------------:|:------------:|
| 결과 |    1    |     NULL      |    NULL    |     1     |        1        |      0       |

### 부정 비교

`<>`와 `!=` 모두 '같지 않다'를 의미하지만, `<>`가 SQL 표준 연산자이므로 사용을 권장한다.

### IN 연산자

`IN` 연산자는 주어진 목록에 포함된 값과 일치하는지를 확인하는 연산자로, 내부적으로는 여러 개의 `OR` 조건과 유사하게 동작한다.

```sql
-- emp_no = 10001 OR emp_no = 10002 와 유사하게 최적화
SELECT *
FROM employees
WHERE emp_no IN (10001, 10002);
```

여러 컬럼을 하나의 쌍으로 묶어도 인덱스 레인지 스캔을 효율적으로 사용할 수 있다.

```sql
-- (dept_no, emp_no)에 다중 컬럼 인덱스가 있다면 효율적으로 처리됨
SELECT *
FROM dept_emp
WHERE (dept_no, emp_no) IN (('d001', 10017), ('d002', 10018));
```

## 논리 연산자

- `AND` (`&&`): 모든 조건이 `TRUE`일 때 `TRUE`를 반환
- `OR` (`||`): 조건 중 하나라도 `TRUE`이면 `TRUE`를 반환
- `NOT` (`!`): `TRUE`를 `FALSE`로, `FALSE`를 `TRUE`로 반전

`&&`, `||`, `!`는 MySQL의 비표준 연산자로, 이식성을 고려하여 `AND`, `OR`, `NOT`을 사용하는 것이 좋다.

## 패턴 매칭 연산자

### LIKE 연산자

문자열의 내용이 특정 패턴과 일치하는지 검사한다.

- `%`: 0개 이상의 모든 문자
- `_`: 정확히 1개의 문자

`LIKE`는 인덱스를 사용할 수 있지만, 와일드카드(`%`, `_`)가 패턴의 시작 부분에 위치하면 인덱스를 사용할 수 없다는 점을 유의해야 한다.

- `WHERE name LIKE '김%';`
    - 인덱스를 사용한 범위 검색(인덱스 레인지 스캔)이 가능
- `WHERE name LIKE '%김';` 또는 `WHERE name LIKE '%김%';`
    - 패턴의 시작 문자를 알 수 없어 인덱스를 효율적으로 탐색할 수 없으므로, 인덱스를 사용하지 못하고 풀 테이블 스캔이 발생

### REGEXP 연산자

`LIKE`보다 더 강력한 정규 표현식을 사용하여 복잡한 패턴 매칭을 수행한다.

- `LIKE`보다 연산 비용이 높음
- B-Tree 인덱스 사용 불가

따라서 대용량 테이블에 `REGEXP`를 사용하면 심각한 성능 저하가 발생할 수 있다.

###### 참고자료

- [Real MySQL 8.0 (2권)](https://kobic.net/book/bookInfo/view.do?isbn=9791158392727)
