# 인덱스(Index)

> 데이터베이스 쿼리의 성능에서 뺴놓을 수 없는 요소 중 하나

컬럼들의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-Value pair)으로 삼아 인덱스를 만들어 놓아 빠르게 데이터를 찾을 수 있도록 도와주는 장치  
하지만 인덱스를 사용하면 데이터를 추가하거나 수정, 삭제하는 작업을 할 때마다 인덱스를 수정해야 하므로 해당 작업에서는 성능이 떨어질 수 있다.

- 실제 프로젝트에서 하나의 컬럼에 대한 B-TREE 인덱스 적용 전/후 시간 차이

```sql
SELECT {{SAME QUERY...}}
-- [2023-04-14 02:52:38] 8 rows retrieved starting from 1 in 3 s 892 ms (execution: 3 s 876 ms, fetching: 16 ms)
-- CREATE INDEX ... completed in 29 s 426 ms
SELECT {{SAME QUERY...}}
-- [2023-04-14 02:53:19] 8 rows retrieved starting from 1 in 73 ms (execution: 55 ms, fetching: 18 ms)
```

## B-Tree 인덱스

> B-Tree 인덱스는 데이터베이스의 인덱스를 구성하는 가장 기본적인 방법, Binary의 B가 아니라 Balanced의 B

### 구조 및 특성

최상위에 하나의 루트 노드가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태로 아래의 노드로 구성된다.

- Root Node: 최상위 노드
- Branch Node: 중간에 있는 노드
- Leaf Node: 가장 하위에 있는 노드로, 실제 데이터 레코드를 찾아가기 위한 주솟값을 가짐

### 인덱스 키의 추가/삭제/변경/검색

- 인덱스 키 추가
    - B-Tree에 저장될 때 저장될 키 값을 이용해 적절한 위치를 탐색 후 리프 노드에 저장
    - 만약 리프 노드가 꽉 차있다면 리프 노드를 분리하고 새로운 리프 노드를 생성하게 되는데, 이 때 상위 브랜치 노드까지 처리 범위가 넓어짐
    - 비교적 많은 비용이 발생할 수 있으며, 비용의 대부분이 메모리와 CPU에서 발생하는 것이 아닌, 디스크에서 읽고/쓰기 작업에 많은 비용(시간)이 발생
    - InnoDB의 경우 인덱스 키 추가 잡업을 지연시켜 나중에 처리하는 방식을 사용(Primary Key, Unique Index 경우 중복체크가 필요하여 즉시 처리)
- 인덱스 키 삭제
    - 해당 키 값이 저장된 B-Tree 리프 노드를 찾아 삭제 마크만 하면 작업 완료
- 인덱스 키 변경
    - B-Tree의 키 값이 변경되는 경우 리프 노드 위치의 변경 필요하며, 이 때 키 값을 삭제한 후 새로운 키 값을 추가하는 방식으로 처리
    - 위의 삭제 및 추가 과정이 절차적으로 진행
- 인덱스 키 검색
    - 위의 비용들을 감수하고 인덱스를 사용하는 이유 중 하나(빠른 탐색)
    - 루트 노드로부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 내려가며 트리 탐색
    - SELECT(조회)에서만 사용되는 것이 아닌 UPDATE/DELETE에서도 인덱스 키 검색을 사용

###### 출처

- [Real MySQL 8.0 1](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=284710853)

[//]: # (8.4 R-Tree 인덱스 / 8.6 함수 기반 인덱스 제외)