# B-Tree 인덱스

> B-Tree 인덱스는 데이터베이스의 인덱스를 구성하는 가장 기본적인 방법, Binary의 B가 아니라 Balanced의 B

## 구조 및 특성

최상위에 하나의 루트 노드가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태로 아래의 노드로 구성된다.

- Root Node: 최상위 노드
- Branch Node: 중간에 있는 노드
- Leaf Node: 가장 하위에 있는 노드로, 실제 데이터 레코드를 찾아가기 위한 주솟값을 가짐

## 인덱스 키의 추가/삭제/변경/검색

- 인덱스 키 추가
    - B-Tree에 저장될 때 저장될 키 값을 이용해 적절한 위치를 탐색 후 리프 노드에 저장
    - 만약 리프 노드가 꽉 차있다면 리프 노드를 분리하고 새로운 리프 노드를 생성하게 되는데, 이 때 상위 브랜치 노드까지 처리 범위가 넓어짐
    - 비교적 많은 비용이 발생할 수 있으며, 비용의 대부분이 메모리와 CPU에서 발생하는 것이 아닌, 디스크에서 읽고/쓰기 작업에 많은 비용(시간)이 발생
    - InnoDB의 경우 인덱스 키 추가 잡업을 지연시켜 나중에 처리하는 방식을 사용(Primary Key, Unique Index 경우 중복체크가 필요하여 즉시 처리)
- 인덱스 키 삭제
    - 해당 키 값이 저장된 B-Tree 리프 노드를 찾아 삭제 마크만 하면 작업 완료
- 인덱스 키 변경
    - B-Tree의 키 값이 변경되는 경우 리프 노드 위치의 변경 필요하며, 이 때 키 값을 삭제한 후 새로운 키 값을 추가하는 방식으로 처리
    - 위의 삭제 및 추가 과정이 절차적으로 진행
- 인덱스 키 검색
    - 위의 비용들을 감수하고 인덱스를 사용하는 이유 중 하나(빠른 탐색)
    - 루트 노드로부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 내려가며 트리 탐색
    - SELECT(조회)에서만 사용되는 것이 아닌 UPDATE/DELETE에서도 인덱스 키 검색을 사용

## 인덱스 사용에 영향을 미치는 요소

인덱스를 구성하는 컬럼의 크기 / 레코드 건수 / 유니크 인덱스 키 값의 개수 등에 따라 변경/조회 성능이 달라질 수 있다.

### 1. 인덱스 키 값의 크기

디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 작업의 최소 단위로 사용된다.  
인덱스도 결국은 페이지 단위로 관리되며, 루트/브랜치/리프 노트를 구분한 기준이 페이지 단위이다.  
B-Tree의 각 노드는 자식 노드를 가지는 갯수는 인덱스 페이지의 크기 + 키 값의 크기에 따라 결정된다.

- 인덱스 페이지 크기: 16KB
- 인덱스 키: 16 Byte
- 자식노드 주소: 12 Byte
- 하나의 인덱스 페이지에 저장할 수 있는 최대 키 값의 개수: 16 * 1024 / (16 + 12) = 585

인덱스의 키가 커지게 되면, 인덱스 페이지에 저장할 수 있는 키 값의 개수가 줄어들게 되고, 이는 인덱스 키 값의 추가/삭제/변경/검색에 대한 비용이 증가하게 된다.

### 2. B-Tree 깊이

B-Tree 인덱스의 깊이는 성능이 중요한 요소 중 하나지만, 직접 제어할 수 있는 요소가 아니다.  
위에서의 인덱스 키 값의 평균 크기가 늘어나면 인덱스의 깊이가 늘어나게 되고, 이는 인덱스 키 값의 추가/삭제/변경/검색에 대한 비용이 증가하게 된다.  
깊이 = 디스크 I/O 횟수로 직결되므로 깊이가 깊어질수록 성능이 저하로 이어지기 때문에, 인덱스 키 값의 평균 크기를 줄이는 것이 성능 향상에 도움이 된다.  
실제로 대용량 데이터베이스에서는 깊이가 5 이상이 되는 경우는 거의 없다.

### 3. 선택도(기수성)

선택도(Selctivity) / 기수성(Cardinality)는 거의 같은 의미로 사용되며, 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.

- 전체 인덱스 키 값: 100개
- 유니크한 값: 10개
- 기수성: 10

중복된 값이 많아지면 기수성이 낮아지게 되고, 이는 인덱스 키 값의 추가/삭제/변경/검색에 대한 비용이 증가하게 된다.

- 예시

```sql
-- 전체 레코드 수: 10000개
-- country + city 중복해서 저장돼 있지 않음
CREATE TABLE tb_test
(
    country VARCHAR(10),
    city    VARCHAR(10),
    INDEX   idx_country (country),
);

-- Case A: Country 컬럼의 유니크한 값의 개수: 10개
-- -- 10개의 국가(country)의 도시(city) 레코드가 존재
-- Case B: Country 컬럼의 유니크한 값의 개수: 1000개
-- -- 1000개의 국가(country)의 도시(city) 레코드가 존재
SELECT *
FROM tb_test
WHERE country = 'Korea'
  AND city = 'Seoul';
```

- 인덱스된 컬럼(country)에 대해서는 전체 레코드의 건수나 유니크한 값의 개수 등에 대한 통계 정보를 가짐
- 전체 레코드 건수를 뉴니크 값 개수로 나누게되면 하나의 키 값으로 검색했을 때 평균적으로 읽어야 하는 레코드 건수를 알 수 있음
- Case A: 평균 1000건 조회
    - 10000 / 10 = 1000건이 일치하는 것으로 예상하게 됨
    - 레코드를 조회하기 위해 평균 999건의 레코드의 불필요한 데이터를 읽음
- Case B: 평균 10건 조회
    - 10000 / 1000 = 10건이 일치하는 것으로 예상하게 됨
    - 레코드를 조회하기 위해 평균 9건의 레코드의 불필요한 데이터를 읽음

### 4. 읽어야 하는 레코드의 건수

- 인덱스를 통해 테이블의 레코드를 읽는 것은 바로 레코드를 읽는 것보다 높은 비용이 발생
- 일반적인 DBMS 옵티마이저에서 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4-5배 정도의 비용 발생
- 때문에 인덱스를 통해 읽어야 할 레코드 건 수가 전체 레코드의 20-25%를 넘어가면 인덱스를 사용하지 않는 것이 더 효율적

## B-Tree 인덱스를 통한 데이터 읽기

### 인덱스 레인지 스캔

인덱스 접근 방법 가운데 가장 대표적인 방법으로,  
아래 쿼리처럼 인덱스 키 값의 범위가 결정되어 있을 때, 시작해야 할 위치를 찾으면 그 위치부터 끝까지 순차적으로 읽어서 검색 조건을 만족하는 레코드를 찾는 방법이다.

```sql
SELECT *
FROM employee
WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾음(인덱스 탐색)
2. 위에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 읽음(인덱스 스캔)
3. 읽어들인 인덱스 키와 레코드 주소를 이용해 한 건 한 건 레코드를 읽어옴(랜덤 I/O 발생)

인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로, 인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘어가면 인덱스를 사용하지 않고 직접 읽는 것이 더 효율적일 수 있다.

#### 커버링 인덱스

원하는 데이터를 인덱스에서만 추출할 수 있는 인덱스를 의미하며, B-Tree 스캔만으로 원하는 데이터를 추출할 수 있기 때문에 레코드를 읽는 작업이 필요 없어서 빠른 성능을 보여준다.

```sql
SELECT first_name
FROM employee
WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

### 인덱스 풀 스캔

인덱스의 처음부터 끝까지 모두 읽는 방식으로, 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 사용된다.  
보통 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 효율적이다.  
쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 아래의 절차를 거치며 인덱스 풀 스캔을 사용한다.(데이터 레코드까지 읽어야 하면 인덱스 풀 스캔을 사용하지 않는다.)

1. 인덱스 리프 노드의 제일 앞(혹은 뒤)으로 이동
2. 인덱스를 차례대로 읽으면서 처음부터 끝까지 스캔

### 루스 인덱스 스캔

듬성듬성하게 인덱스를 읽는 것을 의미한다.  
중간에 필요치 않는 인덱스 키 값은 무시(SKIP)하고 읽는 방식으로, 일반적으로 GROUP BY 또는 MAX(), MIN() 같은 집합 함수에 대해 최적화 하는 경우에 사용한다.

```sql
CREATE INDEX idx_deptno_empno ON dept_emp (dept_no, emp_no);

SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dep_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

위 쿼리에서 인덱스가 (dept_no, emp_no) 조합으로 정렬되어있기 때문에 depth_no 그룹 별로 첫 번째 레코드의 emp_no를 읽어오면 된다.  
즉 인덱스에서 WHERE 조건에 만족하는 범위 전체를 스캔할 필요가 없는 것을 옵티마이저가 판단하고 중간의 레코드는 무시하고 필요한 레코드만 읽어오는 방식이다.

| 리프 노드 페이지 | dept_no | emp_no | dept_name | first_name | 스캔 여부 |
|:---------:|:-------:|:------:|:---------:|:----------:|:-----:|
|     5     |  d002   | 10042  |  Finance  |    Magy    |   O   |
|     5     |  d002   | 10043  |  Finance  |  Yinghua   |   X   |
|     5     |  d002   | 10044  |  Finance  |    Eber    |   X   |
|    ...    |   ...   |  ...   |    ...    |    ...     |  ...  |
|    ...    |   ...   |  ...   |    ...    |    ...     |  ...  |
|     6     |  d003   | 10045  |   Human   |  Kyoichi   |   O   |
|     6     |  d003   | 10046  |   Human   | Eberhardt  |   X   |
|     6     |  d003   | 10047  |   Human   | Admanatios |   X   |
|    ...    |   ...   |  ...   |    ...    |    ...     |  ...  |
|    ...    |   ...   |  ...   |    ...    |    ...     |  ...  |
|     7     |  d004   | 10048  |   Legal   |   Seong    |   O   |
|     7     |  d004   | 10049  |   Legal   |    Ziya    |   X   |
|     7     |  d004   | 10050  |   Legal   |    Eber    |   X   |
|    ...    |   ...   |  ...   |    ...    |    ...     |  ...  |

### 인덱스 스킵 스캔

인덱스의 핵심은 값이 정려되어 있다는 점인데, 이 때문에 인덱스를 구성하는 컬럼 순서가 중요하다.

```sql
ALTER TABLE employees
    ADD INDEX ix_gender_birthdate (gender, birth_date);
```

위 인덱스를 사용하려면 WHERE 조건절에 gender 컬럼에 대한 비교 조건이 필수가 된다.

```sql
-- 1. 인덱스를 사용하지 못하는 쿼리
SELECT *
FROM employees
WHERE birth_date = > '1965-05-09';

-- 2. 인덱스를 사용하는 쿼리
SELECT *
FROM employees
WHERE gender = 'M'
  AND birth_date = > '1965-05-09';
```

위 두 쿼리 중 두 번째 쿼리는 인덱스를 효율적으로 사용할 수 있었고, 첫 번째 쿼리는 인덱스를 사용하지 못했기 때문에 `birth_date` 컬럼부터 시작하는 인덱스를 새로 생성해야 했다.  
하지만 MySQL 8.0 버전부터는 `gender` 컬럼을 건너뛰어서 `birth_date` 컬럼만으로 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입됐다.

```sql
-- 인덱스 스킵 스캔 기능 비활성화
SET
optimizer_switch='skip_scan=off';

EXPLAIN
SELECT gender, birth_date
FROM exployees
WHERE birth_date = > '1965-05-09';
+----+-----------+-------+-------------+----------------------------+
| id | table     | type  | key         | Extra                      |
+----+-----------+-------|-------------+----------------------------+
|  1 | employees | index | ix_g_b      | Using where, Using index   |
+----+-----------+-------+-------------+----------------------------+
-- type 컬럼의 `index` 표시는 인덱스를 처음부터 끝까지 모두 읽었음(풀 인덱스 스캔)을 의미하는 것으로, 인덱스를 비효율적으로 사용했다는 것을 알 수 있다.
    
-- 인덱스 스킵 스캔 기능 활성화
SET optimizer_switch='skip_scan=on';
    
EXPLAIN
SELECT gender, birth_date
FROM exployees
WHERE birth_date = > '1965-05-09';
+----+-----------+-------+-------------+------------------------------------------+
| id | table     | type  | key         | Extra                                    |
+----+-----------+-------|-------------+------------------------------------------+
|  1 | employees | range | ix_g_b      | Using where, Using index for skip scan   |
+----+-----------+-------+-------------+------------------------------------------+
-- type 컬럼의 `range` 표시는 인덱스에서 꼭 필요한 부분만 읽었음을 의미한다.
-- Using index for skip scan 문구는 인덱스 스킵 스캔을 사용했다는 것을 의미한다.
```

인덱스 스킵 스캔은 테이블을 스캔할 때 다음과 같이 처리된다.

| 리프 노드 페이지 | gender | birth_date | 스캔 여부 |
|:---------:|:------:|:----------:|:-----:|
|     5     |   M    | 1965-03-09 |   X   |
|     5     |   M    | 1965-05-09 |   O   |
|     5     |   M    | 1965-06-09 |   O   |
|    ...    |  ...   |    ...     |   O   |
|     6     |   M    | 1965-12-09 |   O   |
|     6     |   F    | 1965-01-09 |   X   |
|     6     |   F    | 1965-02-09 |   X   |
|    ...    |  ...   |    ...     |   X   |
|     7     |   F    | 1965-04-09 |   X   |
|     7     |   F    | 1965-05-09 |   O   |
|     7     |   F    | 1965-06-09 |   O   |
|    ...    |  ...   |    ...     |   O   |

gender 컬럼에서 유니크한 값을 모두 조회하여 주어진 쿼리에 gender 컬럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리하게 된다.

```sql
-- gender 컬럼에 대해 가능한 값 2개('M', 'F')를 구한 뒤 아래 쿼리를 실행하는 것과 비슷한 형태의 최적화를 실행
SELECT gender, birth_date
FROM employees
WHERE gender = 'M'
  AND birth_date > '1965-05-09';
SELECT gender, birth_date
FROM employees
WHERE gender = 'F'
  AND birth_date > '1965-05-09';
```

하지만 아래 두 가지 단점이 존재하게 된다.

- WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 갯수가 적어야 한다.
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 한다.(=커버링 인덱스)
    - 인덱스 외의 컬럼을 필요로 하는 경우 풀 테이블 스캔으로 처리된다.
    - 옵티마이저가 개선되면 해결될 가능성도 있다.

###### 출처

- [Real MySQL 8.0 1](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=284710853)