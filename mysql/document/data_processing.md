# 데이터 처리

MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등 기본 데이터 가공 기능을 가지고 있으며, 엔지별로 데이터 처리 방식은 모두 다르다.

## 쿼리 처리 방법

MySQL에서 쿼리 처리 방법으로 스트리밍 처리와 버퍼링 처리 두 가지 방식으로 나눌 수 있다.

### 스트리밍 처리

서버 쪽에서 처리할 데이터가 얼마인지 관계 없이 조건에 일치하는 레코드가 검색될 때마다 바로 클라이언트로 전송하는 방식이다.  
첫 번째 레코드를 처리하자마자 전달할 수 있으므로 많은 데이터를 조회하는 것과 상관 없이 빠른 응답을 받을 수 있다.

### 버퍼링 방식

ORDER BY / GROUP BY 같은 처리는 모든 레코드를 읽어서 처리해야 하므로 스트리밍 방식으로 처리할 수 없다.

## 리드 어헤드(Read ahead)

> 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것

보통 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 풀 테이블 스캔은 상당히 많은 디스크 읽기가 필요한데, 이를 향상시키기 위해 InnoDB 리드 어헤드(Read Ahead) 기능을 사용한다.  
InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동 시작된다.  
테이블 풀 스캔 시 작업은 아래와 같이 진행된다.

1. 풀 스캔이 실행되면 포그라운드 스레드(Foreground Thread)에 의해 처음 몇 개의 데이터 페이지가 읽힘
2. 특정 시점부터 백그라운드 스레드가 읽기 작업을 시작
3. 백그라운드 스레드는 한 번에 읽는 페이지 수를 늘려가며 읽기 작업을 진행
4. 읽은 페이지를 버퍼 풀에 저장
5. 포그라운드 스레드는 백그라운드 스레드가 읽은 페이지(버퍼 풀)에서 가져다가 사용

풀 테이블 스캔과 풀 인덱스 스캔은 아래와 같은 경우 실행되며 리드 어헤드(Read ahead) 기능을 사용하게 된다.

- 풀 테이블 스캔(Full Table Scan): 아래의 조건을 만족하는 경우 풀 테이블 스캔을 수행한다.
    - 테이블의 레코드 건수가 너무 작아 인덱스를 사용하는 것보다 테이블을 읽는 것이 빠른 경우(보통 테이블이 페지이 1개로 구성된 경우)
    - WHERE 절 혹은 ON 절에 이용할 수 있는 적절한 조건이 없는 경우
    - 인덱스 레인지 스캔을 사용할 수 있지만 옵티마이저 판단한 조건 일치 레코드 건수가 너무 많은 경우
- 풀 인덱스 스캔(Full Index Scan): 모든 레코드를 읽어야 하는 것이 아닌 레코드 건수만 조회하는 경우 풀 인덱스 스캔으로 처리
    - `SELECT COUNT(*) FROM table_name` 같은 경우 가능
    - 용량이 적어 디스크 읽기 횟수가 줄어 훨씬 빠른 속도로 처리

## 병렬 처리

> 하나의 쿼리를 여러 스레드가 작업을 나누어 처리하는 것

MySQL 8.0에서 병렬 처리 기능이 추가되었으나, WHERE 조건 없이 단순이 테이블 전체 건수를 가져오는 경우에만 병렬 처리가 가능하다.  
스레드 수를 늘려 서버에 장착된 코어 개수를 넘어가게 되는 경우 오히려 성능이 떨어질 수 있다.

```mysql
SET SESSION innodb_parallel_read_threads = 4;

SELECT COUNT(*)
FROM TABLE_NAME;
```

## ORDER BY 처리(Using filesort)

레코드 1~2건을 가져올 때를 제외하면 대부분의 SELECT 쿼리에서 정렬은 많이 사용되는데,  
정렬을 처리할 때 인덱스를 이용하는 방법과 쿼리가 실행 될 때 `Filesort`라는 별도의 처리를 이용하는 방법으로 나뉜다.

|  이용 방법   |                                   장점                                   |                                        단점                                         |
|:--------:|:----------------------------------------------------------------------:|:---------------------------------------------------------------------------------:|
|   인덱스    | INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름 | INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림, 인덱스 개수가 늘러날수록 메모리가 많이 필요 |
| Filesort |              인덱스를 생성하지 않아도 되므로 위의 인덱스의 단점이 발생하지 않는 장점이 존재              |                     정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 느려짐                     |

### 소트 버퍼(Sort Buffer)

정렬을 수행하기 위해 별도의 메모리 공간을 할당 받는 공간을 소트 버퍼(Sort Buffer)라고 하며 아래와 같은 특징을 가진다.

- 정렬이 필요한 경우에만 할당
- 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가
    - 최대 사용 가능한 소트 버퍼 공간은 `sort_buffer_size`라는 시스템 변수로 설정 가능
- 쿼리 실행이 완료되면 바로 시스템으로 반납
- 세션 메모리 영역에 해당(클라이언트가 공유해서 사용되는 영역이 아님)

여기서 정렬해야 할 레코드가 메모리에 할당된 소트 버퍼만으로 처리되면 아주 빠르게 정렬된다.  

#### 멀티 머지(Multi Merge)

만약 소트 버퍼를 초과하는 경우엔 레코드를 여러 조각으로 나눠서 처리하며 임시 저장을 위해 디스크를 사용하게 되는데 과정은 아래와 같다.

1. 메모리의 소트 버퍼에서 정렬 수행
2. 그 결과를 임시로 디스크에 기록
3. 다음 레코드를 가져와서 다시 정렬하여 반복적으로 디스크에 임시 저장
4. 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬

4번의 과정을 멀티 머지(Multi Merge)라고 하며, 수행된 멀티 머지 횟수는 상태 변수(`Sort_merge_passes`)에 누적 집계된다.  
위 과정에서 알 수 있듯이 디스크 쓰기와 읽기를 유발하여 레코드 건수가 많을 수록 위 작업 횟수가 많아 진다.  
`sort_buffer_size`를 크게 하더라도 빨라지는 것은 아니며, 세션 메모리 영역이기 때문에 여러 클라이언트가 동시에 사용하면 메모리 부족 현상이 발생할 수 있다.

###### 참고자료

- [Real MySQL 8.0 1 - 개발자와 DBA를 위한 MySQL 실전 가이드](https://www.nl.go.kr/seoji/contents/S80100000000.do?schM=intgr_detail_view_isbn&page=1&pageUnit=10&schType=simple&schStr=Real+MySQL&isbn=9791158392703&cipId=228440237%2C)
