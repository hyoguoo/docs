# 아키텍처

MySQL 서버는 다음과 같은 구조로 되어 있다.

- MySQL 엔진: 클라이언트로부터 접속 및 쿼리 요청을 처리하는 커넥션 헨들러 / SQL 파서 / 전처리기 / 옵티마이저 등을 중심으로 구성된다.
- 스토리지 엔진: 실제 데이터를 디스크 스토리지에 저장하고 읽어오는 역할을 한다.

MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.

## 스레딩 구조

MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 동작하며, 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분된다.

### 포그라운드 스레드(클라이언트 스레드)

> 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 스레드

최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 요청을 처리하여 커넥션을 종료하면 해당 커넥션을 담당하는 스레드는 다시 스레드 캐시(Thread Cache)에 반환된다.  
여기서 이미 스레드 캐시에 일정 개수 이상의 대기 스레드가 있으면, 캐키에 넣지 않고 스레드를 종료 시켜 일정 개수의 스레드만 캐시에 유지한다.  
캐시에 유지되는 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 설정할 수 있다.

### 백그라운드 스레드

MyISAM 스토리지 엔진에서는 해당 사항이 없는 부분이나, InnoDB 스토리지 엔진은 아래의 작업들이 백그라운드 스레드로 동작한다.

- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

이 중 가장 중요한 것은 로그 스레드(Log Thread)와 버퍼의 데이터를 디스크로 쓰는 작업을 처리하는 쓰기 스레드(Write Thread)이다.

## 메모리 구조

MySQL 서버는 글로벌 메모리 영역과, 로컬 메모리 영역으로 구분된다.

- 글로벌 메모리 영역: 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당되며, 모든 클라이언트 스레드가 공유한다.
- 로컬 메모리 영역: 세션 메모리 영역이라고도 하며, MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역

## 쿼리 실행 구조

MySQL 서버는 클라이언트로부터 쿼리를 받으면 다음과 같은 과정을 거쳐 쿼리를 처리한다.

1. SQL 요청
2. 쿼리 파서
    - 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL 인식 최소 단위)을 분리해 트리 형태 구조로 만드는 작업
    - 쿼리 문장의 기본 문법을 검사하고, 문법에 맞지 않는 문장이면 에러를 반환
3. 전처리기
    - 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점 있는지 검사
    - 각 토큰을 테이블 이름이나 칼럼 이름 또는 내장 함수와 같은 개체를 매핑해 해당 객체 존재 여부 및 접근 권한 등 확인
4. 옵티마이저
    - 쿼리 문장을 저렴한 비용으로 처리할 수 있는 최적의 실행 계획을 생성
5. 쿼리 실행 엔진
    - 옵티마이저의 명령을 받아 각 핸들러에 쿼리를 전달
6. 스토리지 엔진(핸들러)
    - 서버 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 읽고 쓰는 역할
    - 스토리지 엔진은 핸들러를 의미
    - InnoDB/MyISAM 등 해당
7. SQL 응답

## InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 하나로, MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금 제공하여 높은 동시성 처리가 가능하고 안정적이며 성능이
뛰어나다.  
InnoDB의 주요 특징은 다음과 같다.

### 프라이머리 키에 의한 클러스터링

InnoDB의 모든 테이블은 프라이머리 키를 기준으로 클러스터링되어 저장된다.(기본 설정)  
디스크에 프라이머리 키 값의 순서대로 데이터가 저장되며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.  
프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔이 상당히 빨리 처리 될 수 있어, 결과적으로 쿼리 실행 계획에서 프라이머리 키는 다른 보조 인덱스에 비해 비중이 높게 설정된다.

### 외래 키 지원

외래 키 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로, MyISAM 같은 테이블에서는 사용할 수 없다.

### MVCC(Multi-Version Concurrency Control)

하나의 레코드에 대해 여러 개의 버전이 관리되는 기능으로, 트랜잭션의 격리 수준에 따라 다른 레코드를 읽을 수 있다.

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행할 수 있다. 때문에 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 수행을 할 수 있다.

### 자동 데드락 감지

내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리해 교착 상태에 빠진 트랜잭션을 찾아 강제로 종료시킨다.  
종료 우선 순위는 트랜잭션 언두 로그의 크기가 가장 큰 트랜잭션부터 종료하며, 더 적게 가진 트랜잭션이 롤백의 대상이 된다.

### 장애 복구 자동화

손실이나 장애로부터 데이터를 보호하기 위한 기능이 내장되어 있고, 장애 복구를 위한 자동화된 기능을 제공한다.

### InnoDB 버퍼 풀

가장 핵심적인 부분으로, 디스크 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.  
쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 한다.  
전체 물리 메모리의 80% 정도로 설정하는 말도 있으나, 단순하게 설정해서 되는 값은 아니며, 작은 값으로 설정해서 조금씩 늘려가는 것이 좋다.

### 언두 로그

트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE) 작업을 수행할 때마다 이전 버전의 데이터를 별도로 백업해 두는데, 백업된 데이터를 언두 로그라고 한다.  
언두 로그는 트랜잭션 보장 / 격리 수준 보장을 하기 위해 사용한다.

### 그 외

Double Write Buffer, Change Buffer, Redo log, Log Buffer, Adaptive Hash Index 등이 있다.

###### 참고자료

- [Real MySQL 8.0 1](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=284710853)