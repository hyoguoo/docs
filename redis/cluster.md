---
layout: editorial
---

# Redis Cluster

레디스 클러스터 모드를 사용하면 추가적인 애플리케이션 아키텍처 변경 없이 인스턴스 간 수평 확장이 가능해지며, 다음과 같은 기능을 제공한다.

- 데이터 샤딩: 데이터 저장소를 수평 확장하며 데이터를 여러 노드에 분산 저장(최대 1,000개 노드까지 지원)
- 고가용성: 마스터-슬레이브 복제를 통해 데이터의 가용성을 보장
    - 최소 3대의 마스터 / 복제본 노드로 구성하는 것이 일반적
    - 하나의 클러스터 구성에 속한 각 노드는 서로 모니터링하여 복제본 노드를 자동 페일오버

## 해시 슬롯(Hash Slot)을 이용한 데이터 샤딩

Redis Cluster는 키를 총 16,384개 슬롯으로 분산한다. 각 키는 `CRC16(키) % 16384` 값으로 슬롯이 결정되며, 슬롯을 소유한 마스터 노드가 해당 키를 책임진다.

- 슬롯 범위: 0 ~ 16383 (총 16,384개)
- 키 -> 슬롯 매핑: `CRC16(key) % 16384`
- 확장/축소 시 슬롯 재분배 가능
    - 노드 추가 시: 일부 슬롯을 새 마스터로 이관(resharding)이 가능
    - 노드 제거/축소 시: 해당 마스터의 슬롯을 다른 마스터로 재분배

```
Slots 0..16383
[ 0 ───────── 5460 ]   -> Master #1
[ 5461 ───── 10922 ]   -> Master #2
[ 10923 ──── 16383 ]   -> Master #3
```

실제 운영에서는 트래픽 특성에 따라 슬롯을 비대칭으로 재분배(resharding)할 수 있다.

## 해시태그(Hash Tag)

Redis Cluster는 키가 속한 해시 슬롯 단위로 샤딩되기 때문에 `MGET`, `MSET`, `SUNION` 등 다중 키 커맨드 같은 서로 다른 슬롯의 키를 동시에 처리할 수 없다.  
함께 사용되는 키들을 같은 슬롯에 저장할 수 있도록 해시태그를 사용하는 방법으로 해결할 수 있다.

- 키 이름에 `{`와 `}`가 있으면 **첫 번째 `{`와 그 뒤 첫 `}` 사이 문자열만 해시 대상으로 사용
- 중괄호가 없거나 짝이 맞지 않으면 키 전체를 해시

| 케이스                 | 키 예시                                           | 다중키 커맨드(MGET)             |
|:--------------------|:-----------------------------------------------|:--------------------------|
| 태그 없음 (슬롯이 다를 수 있음) | `cart:user123:items`, `cart:user123:total`     | 서로 다른 슬롯이면 `CROSSSLOT` 오류 |
| 태그 사용 (같은 슬롯 보장)    | `cart:{user123}:items`, `cart:{user123}:total` | 같은 슬롯이므로 `MGET` 가능        |

## 자동 재구성

센티널과 마찬가지로 클러스터 구조에서도 복제와 자동 페일오버를 이용해 고가용성을 확보할 수 있다.

|  구조  |             설명             |
|:----:|:--------------------------:|
| 센티널  |      센티널 인스턴스를 별도 실행       |
| 클러스터 | 데이터를 저장하는 일반 레디스 노드가 서로 감시 |

클러스터를 사용할 때 발생할 수 있는 재구성은 마스터 노드의 장애로 인한 자동 페일오버와 복제본 마이그레이션이 있다.

|   항목   |        자동 페일오버         |           복제본 마이그레이션           |
|:------:|:----------------------:|:------------------------------:|
|   목적   |    마스터 장애 시 서비스 지속     |      복제본이 없는 마스터에 복제본 보강       |
|  트리거   | 다른 마스터 간 `FAIL` 합의(과반) | 어떤 마스터의 복제본 0개, 다른 마스터의 복제본 여유 |
| 가용성 효과 |      즉시 복구 경로 확보       |        장애 내성 강화(이중화 유지)        |

## 클러스터 동작 방법

클러스터 동작 매커니즘은 다음과 같다.

- 하트비트 패킷
    - 노드들이 `PING`/`PONG` 패킷을 주고 받아 생존 여부와 메타데이터를 주기적으로 교환
    - 발신 노드 관점에서의 클러스터 상태(`down`, `ok`)를 교환
- 해시 슬롯 구성 전파
    - 커맨드에서 사용한 키의 해시 슬롯이 어떤 노드에 있는지 알 수 있도록 하는 것을 목적
    - 하트비트 패킷에 슬롯 정보 포함하거나 업데이트 메시지를 보내는 방식으로 전파
- 노드 핸드셰이크
    - 새 노드를 클러스터에 등록해 가십에 참여시키는 초기 절차
    - 새 노드는 기존 노드에 `CLUSTER MEET` 커맨드를 보내고, 수신한 노드는 다른 노드에 새 노드의 정보를 전파
- 클러스터 라이브 재구성
    - 클러스터가 운영되는 동안 노드를 추가하거나 제거하는 과정
    - 새로운 노드 추가: 빈 노드를 클러스터에 추가한 뒤, 기존 노드에서 일부 슬롯을 새 노드로 이동시키는 방식으로 진행
    - 노드 제거: 기존 노드에서 슬롯을 다른 노드로 이동시키고, 해당 노드를 클러스터에서 제거
- 리디렉션
    - 요청 키의 슬롯 소유주가 다른 노드일 때 올바른 노드로 유도
    - MOVED: 요청하는 해시 슬롯이 다른 노드에 있을 때, 해당 노드의 주소를 포함해 클라이언트에게 전달
    - ASK: 해시 슬롯이 다른 노드로 이동 중의 임시 리디렉션, 해시 슬롯은 변경되었지만 실제 데이터는 아직 이전 노드에 존재할 때 사용
- 장애 감지와 페일오버
    - 특정 노드에 접근할 수 없다는 것을 인지하면 해당 노드의 상태를 변경
    - PFAIL(의심): 개별 노드가 심박 미응답/지연을 감지한 상태
    - FAIL(확정): 마스터 다수의 합의로 장애 확정
- 복제본 선출
    - 복제본은 마스터 FAIL 상태 + 1개 이상의 해시슬롯 보유한 경우 페일오버 시도 시작
    - 모든 마스터 노드에 `FAILOVER_AUTH_REQUEST` 패킷을 보내고 다수의 응답을 받으면 마스터 후보로 선출

###### 참고자료

- [개발자를 위한 레디스](https://kobic.net/book/bookInfo/view.do?isbn=9791161757926)
